package com.ustadmobile.meshrabiya.client

import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withTimeout
import kotlinx.coroutines.launch
import kotlinx.coroutines.flow.MutableSharedFlow
import org.junit.Assert.assertEquals
import org.junit.Test
import java.security.KeyPairGenerator
import java.util.Base64
import java.security.Signature
import java.util.LinkedHashMap

@OptIn(ExperimentalCoroutinesApi::class)
class GossipTransportTest {

    private fun generateEd25519KeyPair(): java.security.KeyPair {
        val kpg = KeyPairGenerator.getInstance("Ed25519")
        return kpg.generateKeyPair()
    }

    private fun jsonEscape(s: String): String = s.replace("\\", "\\\\").replace("\"", "\\\"")

    private fun toJsonString(map: Map<String, Any?>): String {
        val sb = StringBuilder()
        sb.append('{')
        var first = true
        for ((k, v) in map) {
            if (!first) sb.append(',')
            first = false
            sb.append('"').append(jsonEscape(k)).append('"').append(':')
            when (v) {
                null -> sb.append("null")
                is String -> sb.append('"').append(jsonEscape(v)).append('"')
                is Boolean, is Number -> sb.append(v.toString())
                else -> sb.append('"').append(jsonEscape(v.toString())).append('"')
            }
        }
        sb.append('}')
        return sb.toString()
    }

    private fun canonicalize(map: Map<String, Any?>): String {
        val filtered = map.filterKeys { it != "signature" && it != "signerPublicKey" }
        val sorted = filtered.toSortedMap()
        return toJsonString(sorted)
    }

    @Test
    fun `valid signed offer is accepted by MeshrabiyaClient`() = runBlocking {
        val kp = generateEd25519KeyPair()

        val jo = linkedMapOf<String, Any?>()
        jo["requestId"] = "r-123"
        jo["responderNode"] = "onionpub:BBB"
        jo["endpoint"] = "onion://bbb/upload/xyz"
        jo["uploadToken"] = "tok"

        val canonical = canonicalize(jo)

        val signer = Signature.getInstance("Ed25519")
        signer.initSign(kp.private)
        signer.update(canonical.toByteArray(Charsets.UTF_8))
        val sig = signer.sign()

        val sigB64 = Base64.getEncoder().encodeToString(sig)
        val pubB64 = Base64.getEncoder().encodeToString(kp.public.encoded)

        val signed = LinkedHashMap(jo)
        signed["signature"] = sigB64
        signed["signerPublicKey"] = pubB64

        val flow = MutableSharedFlow<String>(replay = 8)
        val transport = GossipTransport(incomingSignedJsonFlow = flow)
        val client = MeshrabiyaClient.Builder().withTransport(transport).build()

        launch { flow.emit(toJsonString(signed)) }

        val offers = withTimeout(2000) { client.collectOffers("r-123", 1000L) }
        assertEquals(1, offers.size)
        val offer = offers[0]
        assertEquals("r-123", offer.requestId)
    }

    @Test
    fun `invalid signature causes offer drop`() = runBlocking {
        val kp = generateEd25519KeyPair()

        val jo = linkedMapOf<String, Any?>()
        jo["requestId"] = "r-999"
        jo["responderNode"] = "onionpub:BBB"
        jo["endpoint"] = "onion://bbb/upload/xyz"
        jo["uploadToken"] = "tok"

        val canonical = canonicalize(jo)

        val signer = Signature.getInstance("Ed25519")
        signer.initSign(kp.private)
        signer.update(canonical.toByteArray(Charsets.UTF_8))
        val sig = signer.sign()

        val sigB64 = Base64.getEncoder().encodeToString(sig)
        val pubB64 = Base64.getEncoder().encodeToString(kp.public.encoded)

        val signed2 = LinkedHashMap(jo)
        signed2["signature"] = sigB64
        signed2["signerPublicKey"] = pubB64

        // Tamper: mutate one of the fields after signing
        val tampered = LinkedHashMap(signed2)
        tampered["tamper"] = true

        val flow = MutableSharedFlow<String>(replay = 8)
        val transport = GossipTransport(incomingSignedJsonFlow = flow)
        val client = MeshrabiyaClient.Builder().withTransport(transport).build()

        launch { flow.emit(toJsonString(tampered)) }

        val offers = withTimeout(2000) { client.collectOffers("r-999", 1000L) }
        assertEquals(0, offers.size)
    }
}
